import * as THREE from 'https://cdn.jsdelivr.net/gh/didibr/sitebackup/pages/9/codepen/module.min.js';

!function () {//SimplexNoise FUNCIONS
  "use strict"; var r = .5 * (Math.sqrt(3) - 1), e = (3 - Math.sqrt(3)) / 6, t = 1 / 6, a = (Math.sqrt(5) - 1) / 4, o = (5 - Math.sqrt(5)) / 20; function i(r) { var e; e = "function" == typeof r ? r : r ? function () { var r = 0, e = 0, t = 0, a = 1, o = (i = 4022871197, function (r) { r = r.toString(); for (var e = 0; e < r.length; e++) { var t = .02519603282416938 * (i += r.charCodeAt(e)); t -= i = t >>> 0, i = (t *= i) >>> 0, i += 4294967296 * (t -= i) } return 2.3283064365386963e-10 * (i >>> 0) }); var i; r = o(" "), e = o(" "), t = o(" "); for (var n = 0; n < arguments.length; n++)(r -= o(arguments[n])) < 0 && (r += 1), (e -= o(arguments[n])) < 0 && (e += 1), (t -= o(arguments[n])) < 0 && (t += 1); return o = null, function () { var o = 2091639 * r + 2.3283064365386963e-10 * a; return r = e, e = t, t = o - (a = 0 | o) } }(r) : Math.random, this.p = n(e), this.perm = new Uint8Array(512), this.permMod12 = new Uint8Array(512); for (var t = 0; t < 512; t++)this.perm[t] = this.p[255 & t], this.permMod12[t] = this.perm[t] % 12 } function n(r) { var e, t = new Uint8Array(256); for (e = 0; e < 256; e++)t[e] = e; for (e = 0; e < 255; e++) { var a = e + ~~(r() * (256 - e)), o = t[e]; t[e] = t[a], t[a] = o } return t } i.prototype = { grad3: new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]), grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]), noise2D: function (t, a) { var o, i, n = this.permMod12, f = this.perm, s = this.grad3, v = 0, h = 0, l = 0, u = (t + a) * r, d = Math.floor(t + u), p = Math.floor(a + u), M = (d + p) * e, m = t - (d - M), c = a - (p - M); m > c ? (o = 1, i = 0) : (o = 0, i = 1); var y = m - o + e, w = c - i + e, g = m - 1 + 2 * e, A = c - 1 + 2 * e, x = 255 & d, q = 255 & p, D = .5 - m * m - c * c; if (D >= 0) { var S = 3 * n[x + f[q]]; v = (D *= D) * D * (s[S] * m + s[S + 1] * c) } var U = .5 - y * y - w * w; if (U >= 0) { var b = 3 * n[x + o + f[q + i]]; h = (U *= U) * U * (s[b] * y + s[b + 1] * w) } var F = .5 - g * g - A * A; if (F >= 0) { var N = 3 * n[x + 1 + f[q + 1]]; l = (F *= F) * F * (s[N] * g + s[N + 1] * A) } return 70 * (v + h + l) }, noise3D: function (r, e, a) { var o, i, n, f, s, v, h, l, u, d, p = this.permMod12, M = this.perm, m = this.grad3, c = .3333333333333333 * (r + e + a), y = Math.floor(r + c), w = Math.floor(e + c), g = Math.floor(a + c), A = (y + w + g) * t, x = r - (y - A), q = e - (w - A), D = a - (g - A); x >= q ? q >= D ? (s = 1, v = 0, h = 0, l = 1, u = 1, d = 0) : x >= D ? (s = 1, v = 0, h = 0, l = 1, u = 0, d = 1) : (s = 0, v = 0, h = 1, l = 1, u = 0, d = 1) : q < D ? (s = 0, v = 0, h = 1, l = 0, u = 1, d = 1) : x < D ? (s = 0, v = 1, h = 0, l = 0, u = 1, d = 1) : (s = 0, v = 1, h = 0, l = 1, u = 1, d = 0); var S = x - s + t, U = q - v + t, b = D - h + t, F = x - l + 2 * t, N = q - u + 2 * t, C = D - d + 2 * t, P = x - 1 + .5, T = q - 1 + .5, _ = D - 1 + .5, j = 255 & y, k = 255 & w, z = 255 & g, B = .6 - x * x - q * q - D * D; if (B < 0) o = 0; else { var E = 3 * p[j + M[k + M[z]]]; o = (B *= B) * B * (m[E] * x + m[E + 1] * q + m[E + 2] * D) } var G = .6 - S * S - U * U - b * b; if (G < 0) i = 0; else { var H = 3 * p[j + s + M[k + v + M[z + h]]]; i = (G *= G) * G * (m[H] * S + m[H + 1] * U + m[H + 2] * b) } var I = .6 - F * F - N * N - C * C; if (I < 0) n = 0; else { var J = 3 * p[j + l + M[k + u + M[z + d]]]; n = (I *= I) * I * (m[J] * F + m[J + 1] * N + m[J + 2] * C) } var K = .6 - P * P - T * T - _ * _; if (K < 0) f = 0; else { var L = 3 * p[j + 1 + M[k + 1 + M[z + 1]]]; f = (K *= K) * K * (m[L] * P + m[L + 1] * T + m[L + 2] * _) } return 32 * (o + i + n + f) }, noise4D: function (r, e, t, i) { var n, f, s, v, h, l, u, d, p, M, m, c, y, w, g, A, x, q = this.perm, D = this.grad4, S = (r + e + t + i) * a, U = Math.floor(r + S), b = Math.floor(e + S), F = Math.floor(t + S), N = Math.floor(i + S), C = (U + b + F + N) * o, P = r - (U - C), T = e - (b - C), _ = t - (F - C), j = i - (N - C), k = 0, z = 0, B = 0, E = 0; P > T ? k++ : z++, P > _ ? k++ : B++, P > j ? k++ : E++, T > _ ? z++ : B++, T > j ? z++ : E++, _ > j ? B++ : E++; var G = P - (l = k >= 3 ? 1 : 0) + o, H = T - (u = z >= 3 ? 1 : 0) + o, I = _ - (d = B >= 3 ? 1 : 0) + o, J = j - (p = E >= 3 ? 1 : 0) + o, K = P - (M = k >= 2 ? 1 : 0) + 2 * o, L = T - (m = z >= 2 ? 1 : 0) + 2 * o, O = _ - (c = B >= 2 ? 1 : 0) + 2 * o, Q = j - (y = E >= 2 ? 1 : 0) + 2 * o, R = P - (w = k >= 1 ? 1 : 0) + 3 * o, V = T - (g = z >= 1 ? 1 : 0) + 3 * o, W = _ - (A = B >= 1 ? 1 : 0) + 3 * o, X = j - (x = E >= 1 ? 1 : 0) + 3 * o, Y = P - 1 + 4 * o, Z = T - 1 + 4 * o, $ = _ - 1 + 4 * o, rr = j - 1 + 4 * o, er = 255 & U, tr = 255 & b, ar = 255 & F, or = 255 & N, ir = .6 - P * P - T * T - _ * _ - j * j; if (ir < 0) n = 0; else { var nr = q[er + q[tr + q[ar + q[or]]]] % 32 * 4; n = (ir *= ir) * ir * (D[nr] * P + D[nr + 1] * T + D[nr + 2] * _ + D[nr + 3] * j) } var fr = .6 - G * G - H * H - I * I - J * J; if (fr < 0) f = 0; else { var sr = q[er + l + q[tr + u + q[ar + d + q[or + p]]]] % 32 * 4; f = (fr *= fr) * fr * (D[sr] * G + D[sr + 1] * H + D[sr + 2] * I + D[sr + 3] * J) } var vr = .6 - K * K - L * L - O * O - Q * Q; if (vr < 0) s = 0; else { var hr = q[er + M + q[tr + m + q[ar + c + q[or + y]]]] % 32 * 4; s = (vr *= vr) * vr * (D[hr] * K + D[hr + 1] * L + D[hr + 2] * O + D[hr + 3] * Q) } var lr = .6 - R * R - V * V - W * W - X * X; if (lr < 0) v = 0; else { var ur = q[er + w + q[tr + g + q[ar + A + q[or + x]]]] % 32 * 4; v = (lr *= lr) * lr * (D[ur] * R + D[ur + 1] * V + D[ur + 2] * W + D[ur + 3] * X) } var dr = .6 - Y * Y - Z * Z - $ * $ - rr * rr; if (dr < 0) h = 0; else { var pr = q[er + 1 + q[tr + 1 + q[ar + 1 + q[or + 1]]]] % 32 * 4; h = (dr *= dr) * dr * (D[pr] * Y + D[pr + 1] * Z + D[pr + 2] * $ + D[pr + 3] * rr) } return 27 * (n + f + s + v + h) } }, i._buildPermutationTable = n,
    "undefined" != typeof define && define.amd && define((function () { return i })),
    "undefined" != typeof exports ? exports.SimplexNoise = i :
      "undefined" != typeof window && (window.SimplexNoise = i),
    "undefined" != typeof module && (module.exports = i);

}();


class Terrain{constructor(t,e,s={}){this.scene=t,this.camera=e,this.chunkSize=s.chunkSize||100,this.chunkResolution=s.chunkResolution||50,this.renderDistance=s.renderDistance||2,this.noiseScale=s.noiseScale||.02,this.noiseAmplitude=s.noiseAmplitude||15,this.octaves=4,this.persistence=.5,this.lacunarity=2;const i=this.noiseAmplitude*((1-Math.pow(this.persistence,this.octaves))/(1-this.persistence));this.minHeight=-i,this.maxHeight=i,this.heightRanges={grass:{min:0,max:.4},rock:{min:.3,max:.7},snow:{min:.6,max:1}},this.simplex=new SimplexNoise("world1"),this.chunks=new Map,this.chunkData=new Map,this.heightCache=new Map,this.loadChunksFromJSON(),this.scene.fog=new THREE.FogExp2(13421772,.006),this.creatematerial(),this.createSunAndLight()}setHeight(t,e,s){if(this.heightRanges[t]){const i=e/100,n=s/100;this.heightRanges[t].min=i,this.heightRanges[t].max=n,this.material&&this.material.uniforms[`${t}Min`]&&(this.material.uniforms[`${t}Min`].value=i,this.material.uniforms[`${t}Max`].value=n)}else console.warn(`Texture ${t} does not exist.`)}setBlendRange(t){this.material&&this.material.uniforms.blendRange&&(this.material.uniforms.blendRange.value=t)}setTextureScale(t,e){this.material&&this.material.uniforms[`${t}Scale`]?this.material.uniforms[`${t}Scale`].value=e:console.warn(`Texture scale uniform not found for: ${t}`)}setSunPositionByHour(t=50){const e=Math.max(0,Math.min(t,100))/100,s=Math.max(0,90-90*Math.abs(2*e-1)),i=THREE.MathUtils.lerp(90,270,e),n=THREE.MathUtils.degToRad(90-s),a=THREE.MathUtils.degToRad(i);this.sunVector.setFromSphericalCoords(1,n,a);const o=new THREE.Vector3;o.copy(this.camera.position),o.addScaledVector(this.sunVector,500),this.sunLight.position.copy(o),this.sunLight.target.position.copy(this.camera.position),this.sunLight.target.updateMatrixWorld(),this.sky&&this.sky.material.uniforms.sunPosition.value.copy(this.sunVector)}createSunAndLight(){const t=100;this.sunLight=new THREE.DirectionalLight(16777215,1),this.sunLight.castShadow=!0,this.sunLight.shadow.mapSize.set(512,512),this.sunLight.shadow.camera.near=1,this.sunLight.shadow.camera.far=t,this.sunLight.shadow.camera.left=-100,this.sunLight.shadow.camera.right=t,this.sunLight.shadow.camera.top=t,this.sunLight.shadow.camera.bottom=-100,this.sunLight.shadow.bias=-.005,this.scene.add(this.sunLight),this.sky=new THREE.Sky,this.sky.scale.setScalar(45e4),this.scene.add(this.sky),this.sunVector=new THREE.Vector3,this.sky.material.uniforms.turbidity.value=10,this.sky.material.uniforms.rayleigh.value=3,this.sky.material.uniforms.mieCoefficient.value=.005,this.sky.material.uniforms.mieDirectionalG.value=.7,this.setSunPositionByHour(10)}creatematerial(){const t=new THREE.TextureLoader,e=t.load("https://didisoftwares.ddns.net/9/terrain/grass.jpg"),s=t.load("https://didisoftwares.ddns.net/9/terrain/rock.jpg"),i=t.load("https://didisoftwares.ddns.net/9/terrain/snow.jpg");e.wrapS=e.wrapT=THREE.RepeatWrapping,s.wrapS=s.wrapT=THREE.RepeatWrapping,i.wrapS=i.wrapT=THREE.RepeatWrapping;const n=new THREE.MeshStandardMaterial({color:16777215,transparent:!0,alphaTest:.01});n.onBeforeCompile=t=>{t.uniforms.grassTex={value:e},t.uniforms.rockTex={value:s},t.uniforms.snowTex={value:i},t.uniforms.chunkSize={value:this.chunkSize},t.uniforms.grassScale={value:.2},t.uniforms.rockScale={value:.3},t.uniforms.snowScale={value:.05},t.uniforms.grassMin={value:this.heightRanges.grass.min},t.uniforms.grassMax={value:this.heightRanges.grass.max},t.uniforms.rockMin={value:this.heightRanges.rock.min},t.uniforms.rockMax={value:this.heightRanges.rock.max},t.uniforms.snowMin={value:this.heightRanges.snow.min},t.uniforms.snowMax={value:this.heightRanges.snow.max};const a=this.noiseAmplitude*((1-Math.pow(.5,4))/.5),o=-a,r=a;t.uniforms.minHeight={value:o},t.uniforms.maxHeight={value:r},t.uniforms.blendRange={value:.05},t.uniforms.cameraXZ={value:new THREE.Vector2(0,0)},t.vertexShader="\n          varying float vHeight;\n          varying vec2 vUv;\n          varying vec2 vWorldXZ;\n      "+t.vertexShader,t.vertexShader=t.vertexShader.replace("#include <uv_vertex>","\n          vUv = uv;\n          vHeight = position.y;\n          vec4 worldPos = modelMatrix * vec4(position, 1.0);\n          vWorldXZ = worldPos.xz;\n          "),t.fragmentShader="\n          uniform sampler2D grassTex;\n          uniform sampler2D rockTex;\n          uniform sampler2D snowTex;\n\n          uniform float chunkSize;\n          uniform float grassScale;\n          uniform float rockScale;\n          uniform float snowScale;\n\n          uniform float grassMin;\n          uniform float grassMax;\n          uniform float rockMin;\n          uniform float rockMax;\n          uniform float snowMin;\n          uniform float snowMax;\n\n          uniform float minHeight;\n          uniform float maxHeight;\n          uniform float blendRange;\n\n          uniform vec2 cameraXZ;\n\n          varying float vHeight;\n          varying vec2 vUv;\n          varying vec2 vWorldXZ;\n      "+t.fragmentShader,t.fragmentShader=t.fragmentShader.replace("#include <map_fragment>","\n          float hNorm = clamp((vHeight - minHeight) / (maxHeight - minHeight), 0.0, 1.0);\n\n          float gT = smoothstep(grassMin - blendRange, grassMin + blendRange, hNorm) * \n                     (1.0 - smoothstep(grassMax - blendRange, grassMax + blendRange, hNorm));\n          float rT = smoothstep(rockMin - blendRange, rockMin + blendRange, hNorm) * \n                     (1.0 - smoothstep(rockMax - blendRange, rockMax + blendRange, hNorm));\n          float sT = smoothstep(snowMin - blendRange, snowMin + blendRange, hNorm) * \n                     (1.0 - smoothstep(snowMax - blendRange, snowMax + blendRange, hNorm));\n\n          float total = gT + rT + sT;\n          if (total > 0.0) {\n              gT /= total;\n              rT /= total;\n              sT /= total;\n          }\n\n          vec3 grass = texture2D(grassTex, vUv * chunkSize * grassScale).rgb;\n          vec3 rock = texture2D(rockTex, vUv * chunkSize * rockScale).rgb;\n          vec3 snow = texture2D(snowTex, vUv * chunkSize * snowScale).rgb;\n\n          vec4 texColor = vec4(grass * gT + rock * rT + snow * sT, 1.0);\n\n          // Transparência radial baseada na distância XZ para a câmera (posição global)\n          float dist = distance(vWorldXZ, cameraXZ);\n\n          float radius = 160.0;     // alcance do efeito de transparência\n          float fadeRange = 40.0;   // suavidade da borda da transparência\n\n          // alpha vai de 1.0 no centro (próximo da câmera) até 0.0 no raio externo\n          float alpha = smoothstep(radius, radius - fadeRange, dist);\n\n          texColor.a = alpha;\n\n          diffuseColor *= texColor;\n          diffuseColor.a *= texColor.a;\n          "),n.uniforms=t.uniforms},this.material=n}getHeightInterpolatedWithMods(t,e){const s=Math.floor(t),i=Math.floor(e),n=t-s,a=e-i,o=(t,e)=>{const s=this.generateHeight(t,e),i=`${Math.floor(t/this.chunkSize)}_${Math.floor(e/this.chunkSize)}`;return s+(this.getLocalModification(i,t,e)||0)};return(o(s,i)*(1-n)+o(s+1,i)*n)*(1-a)+(o(s,i+1)*(1-n)+o(s+1,i+1)*n)*a}computeNormalAt(t,e){const s=.5,i=this.getHeightInterpolatedWithMods(t-s,e)-this.getHeightInterpolatedWithMods(t+s,e),n=this.getHeightInterpolatedWithMods(t,e-s)-this.getHeightInterpolatedWithMods(t,e+s),a=new THREE.Vector3(i,2,n);return a.normalize(),a}generateHeight(t,e){const s=`${Math.floor(10*t)}_${Math.floor(10*e)}`;if(this.heightCache.has(s))return this.heightCache.get(s);let i=0,n=this.noiseScale,a=this.noiseAmplitude;for(let s=0;s<this.octaves;s++)i+=this.simplex.noise2D(t*n,e*n)*a,a*=this.persistence,n*=this.lacunarity;return this.heightCache.set(s,i),i}rebuildChunk(t,e){const s=`${t}_${e}`,i=this.chunks.get(s);if(!i)return;const n=i.geometry,a=n.attributes.position;for(let s=0;s<a.count;s++){const i=a.getX(s)+t*this.chunkSize,n=a.getZ(s)+e*this.chunkSize,o=this.getHeightInterpolatedWithMods(i,n);a.setY(s,o)}a.needsUpdate=!0;const o=n.attributes.normal;for(let s=0;s<a.count;s++){const i=a.getX(s)+t*this.chunkSize,n=a.getZ(s)+e*this.chunkSize,r=this.computeNormalAt(i,n);o.setXYZ(s,r.x,r.y,r.z)}o.needsUpdate=!0}createChunk(t,e){const s=`${t}_${e}`;if(this.chunks.has(s))return;const i=new THREE.PlaneGeometry(this.chunkSize,this.chunkSize,this.chunkResolution,this.chunkResolution);i.rotateX(-Math.PI/2);const n=i.attributes.position;for(let s=0;s<n.count;s++){const i=n.getX(s)+t*this.chunkSize,a=n.getZ(s)+e*this.chunkSize,o=this.getHeightInterpolatedWithMods(i,a);n.setY(s,o)}n.needsUpdate=!0;const a=i.attributes.normal;for(let s=0;s<n.count;s++){const i=n.getX(s)+t*this.chunkSize,o=n.getZ(s)+e*this.chunkSize,r=this.computeNormalAt(i,o);a.setXYZ(s,r.x,r.y,r.z)}a.needsUpdate=!0;const o=new THREE.Mesh(i,this.material);o.position.set(t*this.chunkSize,0,e*this.chunkSize),o.receiveShadow=!0,this.scene.add(o),this.chunks.set(s,o)}saveChunksToJSON(){const t={};for(const[e,s]of this.chunkData)t[e]=s;localStorage.setItem("terrainData",JSON.stringify(t))}loadChunksFromJSON(){const t=localStorage.getItem("terrainData");if(!t)return;const e=JSON.parse(t);for(const t in e)this.chunkData.set(t,e[t]);for(const t of this.chunkData.keys()){const[e,s]=t.split("_").map(Number);this.chunks.has(t)&&this.rebuildChunk(e,s)}}getLocalModification(t,e,s){const i=this.chunkData.get(t);if(!i)return null;let n=0;for(const t of i){const i=e-t.x,a=s-t.z,o=Math.sqrt(i*i+a*a);o<5&&(n+=t.deltaHeight*(1-o/5))}return n}applyModification(t,e,s,i,n){const a=`${t}_${e}`;this.chunkData.has(a)||this.chunkData.set(a,[]),this.chunkData.get(a).push({x:s,z:i,deltaHeight:n}),this.rebuildChunk(t,e);const o=[[t-1,e],[t+1,e],[t,e-1],[t,e+1]];for(const[t,e]of o){const s=`${t}_${e}`;this.chunks.has(s)&&this.rebuildChunk(t,e)}}updateShadowCamera(){const t=this.sunLight.shadow.camera;t.position.copy(this.camera.position),t.left=-200,t.right=200,t.top=200,t.bottom=-200,t.near=1,t.far=1e3,t.updateProjectionMatrix()}update(){this.updateShadowCamera();const t=Math.floor(this.camera.position.x/this.chunkSize),e=Math.floor(this.camera.position.z/this.chunkSize);this.material?.uniforms&&this.material.uniforms.cameraXZ.value.set(this.camera.position.x,this.camera.position.z);const s=new Set;for(let i=-this.renderDistance;i<=this.renderDistance;i++)for(let n=-this.renderDistance;n<=this.renderDistance;n++){const a=`${t+i}_${e+n}`;s.add(a),this.createChunk(t+i,e+n)}for(const[t,e]of this.chunks)s.has(t)||(this.scene.remove(e),e.geometry.dispose(),this.chunks.delete(t))}}export{Terrain};